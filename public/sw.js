/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./public/sw.js":
/*!**********************!*\
  !*** ./public/sw.js ***!
  \**********************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Service Worker PWA complet - EMB\n// Version augmentée pour éviter les rafraîchissements et améliorer le cache\n// Service Worker TOUJOURS ACTIF avec gestion automatique\nconst CACHE_VERSION = \"emb-v1.2.0\";\nconst STATIC_CACHE = \"\".concat(CACHE_VERSION, \"-static\");\nconst DYNAMIC_CACHE = \"\".concat(CACHE_VERSION, \"-dynamic\");\nconst API_CACHE = \"\".concat(CACHE_VERSION, \"-api\");\nconst RUNTIME_CACHE = \"\".concat(CACHE_VERSION, \"-runtime\");\n// Workbox precache manifest - sera remplacé par next-pwa lors du build\nconst WB_MANIFEST = [] || [];\n// Assets à précacher (essentiels pour le fonctionnement offline)\nconst PRECACHE_URLS = [\n    \"/\",\n    \"/offline.html\",\n    \"/manifest.json\",\n    \"/config.json\",\n    \"/logo.png\",\n    \"/icon-192x192.png\",\n    \"/icon-512x512.png\",\n    // Ajouter les assets générés par Workbox\n    ...WB_MANIFEST.map((entry)=>typeof entry === \"string\" ? entry : entry.url)\n];\n// Durées de cache (en secondes)\nconst CACHE_DURATION = {\n    short: 5 * 60,\n    medium: 30 * 60,\n    long: 24 * 60 * 60\n};\n// ==================== INSTALLATION ====================\nself.addEventListener(\"install\", (event)=>{\n    console.log(\"[SW] Installation v\" + CACHE_VERSION);\n    event.waitUntil(caches.open(STATIC_CACHE).then((cache)=>{\n        console.log(\"[SW] Pr\\xe9caching des assets essentiels\");\n        return cache.addAll(PRECACHE_URLS).catch((error)=>{\n            console.error(\"[SW] Erreur pr\\xe9cache:\", error);\n        // Continuer même en cas d'erreur pour ne pas bloquer l'installation\n        });\n    }).then(()=>{\n        console.log(\"[SW] Installation termin\\xe9e - Activation automatique\");\n        // Forcer l'activation immédiate du nouveau service worker\n        return self.skipWaiting();\n    }));\n});\n// ==================== ACTIVATION ====================\nself.addEventListener(\"activate\", (event)=>{\n    console.log(\"[SW] Activation v\" + CACHE_VERSION);\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        // Supprimer les anciens caches\n        return Promise.all(cacheNames.filter((name)=>name.startsWith(\"emb-\") && name !== STATIC_CACHE && name !== DYNAMIC_CACHE && name !== API_CACHE && name !== RUNTIME_CACHE).map((name)=>{\n            console.log(\"[SW] Suppression ancien cache:\", name);\n            return caches.delete(name);\n        }));\n    }).then(()=>{\n        console.log(\"[SW] Service Worker activ\\xe9 et prend le contr\\xf4le de toutes les pages\");\n        return self.clients.claim();\n    }).then(()=>{\n        // Notifier tous les clients que le SW est actif\n        return self.clients.matchAll().then((clients1)=>{\n            clients1.forEach((client)=>{\n                client.postMessage({\n                    type: \"SW_ACTIVATED\",\n                    version: CACHE_VERSION\n                });\n            });\n        });\n    }));\n});\n// ==================== FETCH (Stratégies de cache) ====================\nself.addEventListener(\"fetch\", (event)=>{\n    var _request_headers_get;\n    const { request } = event;\n    const url = new URL(request.url);\n    // Ignorer les requêtes non-GET\n    if (request.method !== \"GET\") {\n        return;\n    }\n    // Ne pas cacher config.json - toujours récupérer la version fraîche\n    if (url.pathname === \"/config.json\") {\n        event.respondWith(fetch(request, {\n            cache: \"no-store\"\n        }).catch(()=>caches.match(request)));\n        return;\n    }\n    // Stratégie pour les requêtes API - Network First avec timeout court\n    if (url.pathname.startsWith(\"/api/\")) {\n        event.respondWith(networkFirstWithTimeoutStrategy(request, API_CACHE, 3000));\n        return;\n    }\n    // Stratégie pour les images - Cache First\n    if (request.destination === \"image\") {\n        event.respondWith(cacheFirstStrategy(request, DYNAMIC_CACHE));\n        return;\n    }\n    // Stratégie pour les assets statiques (JS, CSS, fonts) - Cache First\n    if (request.destination === \"script\" || request.destination === \"style\" || request.destination === \"font\") {\n        event.respondWith(cacheFirstStrategy(request, STATIC_CACHE));\n        return;\n    }\n    // Stratégie OPTIMALE pour les pages HTML - Stale-While-Revalidate\n    // Sert immédiatement du cache tout en mettant à jour en arrière-plan\n    // ÉVITE LES RAFRAÎCHISSEMENTS !\n    if (request.destination === \"document\" || ((_request_headers_get = request.headers.get(\"accept\")) === null || _request_headers_get === void 0 ? void 0 : _request_headers_get.includes(\"text/html\"))) {\n        event.respondWith(staleWhileRevalidateStrategy(request, RUNTIME_CACHE));\n        return;\n    }\n    // Par défaut - Stale-While-Revalidate\n    event.respondWith(staleWhileRevalidateStrategy(request, RUNTIME_CACHE));\n});\n// ==================== STRATÉGIES DE CACHE ====================\n// Network First: Essaie le réseau d'abord, puis le cache\nasync function networkFirstStrategy(request, cacheName) {\n    try {\n        const response = await fetch(request);\n        // Mettre en cache seulement les réponses valides\n        if (response.status === 200) {\n            const cache = await caches.open(cacheName);\n            cache.put(request, response.clone());\n        }\n        return response;\n    } catch (error) {\n        // Si le réseau échoue, chercher dans le cache\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            return cachedResponse;\n        }\n        // Fallback vers la page offline pour les pages HTML\n        if (request.destination === \"document\") {\n            return caches.match(\"/offline.html\");\n        }\n        throw error;\n    }\n}\n// Cache First: Cherche dans le cache d'abord, puis le réseau\nasync function cacheFirstStrategy(request, cacheName) {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n        return cachedResponse;\n    }\n    try {\n        const response = await fetch(request);\n        if (response.status === 200) {\n            const cache = await caches.open(cacheName);\n            cache.put(request, response.clone());\n        }\n        return response;\n    } catch (error) {\n        console.error(\"[SW] Erreur fetch:\", error);\n        throw error;\n    }\n}\n// Stale-While-Revalidate: Retourne le cache immédiatement et met à jour en arrière-plan\n// MEILLEURE STRATÉGIE POUR ÉVITER LES RAFRAÎCHISSEMENTS\nasync function staleWhileRevalidateStrategy(request, cacheName) {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await caches.match(request);\n    // Promesse de mise à jour en arrière-plan\n    const fetchPromise = fetch(request).then((response)=>{\n        // Mettre à jour le cache en arrière-plan uniquement si succès\n        if (response.status === 200) {\n            cache.put(request, response.clone());\n        }\n        return response;\n    }).catch((error)=>{\n        console.error(\"[SW] Erreur fetch background:\", error);\n        return null;\n    });\n    // Retourner immédiatement le cache s'il existe, sinon attendre le réseau\n    return cachedResponse || fetchPromise || caches.match(\"/offline.html\");\n}\n// Network First avec timeout: Essaie le réseau avec un timeout, puis le cache\nasync function networkFirstWithTimeoutStrategy(request, cacheName) {\n    let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3000;\n    try {\n        // Créer une promesse avec timeout\n        const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Timeout\")), timeout));\n        const fetchPromise = fetch(request);\n        // Course entre fetch et timeout\n        const response = await Promise.race([\n            fetchPromise,\n            timeoutPromise\n        ]);\n        // Mettre en cache seulement les réponses valides\n        if (response.status === 200) {\n            const cache = await caches.open(cacheName);\n            cache.put(request, response.clone());\n        }\n        return response;\n    } catch (error) {\n        // Si timeout ou erreur réseau, chercher dans le cache\n        const cachedResponse = await caches.match(request);\n        if (cachedResponse) {\n            console.log(\"[SW] Utilisation du cache suite \\xe0 timeout/erreur\");\n            return cachedResponse;\n        }\n        // Fallback vers la page offline pour les documents\n        if (request.destination === \"document\") {\n            return caches.match(\"/offline.html\");\n        }\n        throw error;\n    }\n}\n// ==================== NOTIFICATIONS PUSH ====================\nself.addEventListener(\"push\", (event)=>{\n    console.log(\"[SW] Push re\\xe7u:\", event);\n    const defaultOptions = {\n        icon: \"/logo.png\",\n        badge: \"/logo.png\",\n        vibrate: [\n            200,\n            100,\n            200\n        ],\n        requireInteraction: true,\n        actions: [\n            {\n                action: \"open\",\n                title: \"Ouvrir\"\n            },\n            {\n                action: \"close\",\n                title: \"Fermer\"\n            }\n        ]\n    };\n    let notificationData = {\n        title: \"EMB Transfer\",\n        body: \"Nouvelle notification\",\n        ...defaultOptions\n    };\n    if (event.data) {\n        try {\n            const data = event.data.json();\n            notificationData = {\n                title: data.title || \"EMB Transfer\",\n                body: data.message || data.body || \"Nouvelle notification\",\n                icon: data.icon || defaultOptions.icon,\n                badge: data.badge || defaultOptions.badge,\n                data: data,\n                vibrate: defaultOptions.vibrate,\n                requireInteraction: defaultOptions.requireInteraction,\n                actions: defaultOptions.actions,\n                tag: data.tag || \"emb-notification\",\n                renotify: true\n            };\n        } catch (e) {\n            console.error(\"[SW] Erreur parsing notification:\", e);\n        }\n    }\n    event.waitUntil(self.registration.showNotification(notificationData.title, notificationData));\n});\nself.addEventListener(\"notificationclick\", (event)=>{\n    console.log(\"[SW] Notification cliqu\\xe9e:\", event);\n    event.notification.close();\n    if (event.action === \"close\") {\n        return;\n    }\n    event.waitUntil(clients.matchAll({\n        type: \"window\",\n        includeUncontrolled: true\n    }).then((clientList)=>{\n        // Chercher une fenêtre ouverte et la focus\n        for (const client of clientList){\n            if (client.url.indexOf(self.location.origin) >= 0 && \"focus\" in client) {\n                return client.focus();\n            }\n        }\n        // Ouvrir une nouvelle fenêtre si aucune n'est ouverte\n        if (clients.openWindow) {\n            return clients.openWindow(\"/dashboard\");\n        }\n    }));\n});\nself.addEventListener(\"notificationclose\", (event)=>{\n    console.log(\"[SW] Notification ferm\\xe9e:\", event);\n});\n// ==================== BACKGROUND SYNC ====================\nself.addEventListener(\"sync\", (event)=>{\n    console.log(\"[SW] Background sync:\", event.tag);\n    if (event.tag === \"sync-transactions\") {\n        event.waitUntil(syncTransactions());\n    }\n});\nasync function syncTransactions() {\n    try {\n        // Synchroniser les données en attente\n        console.log(\"[SW] Synchronisation des transactions...\");\n    // Implémenter la logique de synchronisation ici\n    } catch (error) {\n        console.error(\"[SW] Erreur sync:\", error);\n    }\n}\n// ==================== PERIODIC BACKGROUND SYNC ====================\nself.addEventListener(\"periodicsync\", (event)=>{\n    console.log(\"[SW] Periodic sync:\", event.tag);\n    if (event.tag === \"content-sync\") {\n        event.waitUntil(periodicContentSync());\n    }\n});\nasync function periodicContentSync() {\n    try {\n        console.log(\"[SW] Synchronisation p\\xe9riodique du contenu...\");\n        // Cette fonction s'exécute périodiquement pour maintenir le SW actif\n        // et synchroniser les données en arrière-plan\n        // Vérifier et mettre à jour les caches critiques\n        const cache = await caches.open(STATIC_CACHE);\n        const cachedUrls = await cache.keys();\n        console.log(\"[SW] Contenu en cache:\", cachedUrls.length, \"\\xe9l\\xe9ments\");\n    } catch (error) {\n        console.error(\"[SW] Erreur sync p\\xe9riodique:\", error);\n    }\n}\n// ==================== MESSAGE ====================\nself.addEventListener(\"message\", (event)=>{\n    console.log(\"[SW] Message re\\xe7u:\", event.data);\n    if (event.data && event.data.type === \"SKIP_WAITING\") {\n        self.skipWaiting();\n    }\n    if (event.data && event.data.type === \"CLEAR_CACHE\") {\n        event.waitUntil(caches.keys().then((cacheNames)=>{\n            return Promise.all(cacheNames.map((name)=>caches.delete(name)));\n        }));\n    }\n    if (event.data && event.data.type === \"CHECK_UPDATE\") {\n        // Forcer la vérification de mise à jour\n        event.waitUntil(self.registration.update().then(()=>{\n            console.log(\"[SW] V\\xe9rification de mise \\xe0 jour effectu\\xe9e\");\n        }));\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TCxRQUFRQyxHQUFHLENBQUM7UUFDZDtJQUVKO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3N3LmpzPzRiODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2VydmljZSBXb3JrZXIgUFdBIGNvbXBsZXQgLSBFTUJcbi8vIFZlcnNpb24gYXVnbWVudMOpZSBwb3VyIMOpdml0ZXIgbGVzIHJhZnJhw65jaGlzc2VtZW50cyBldCBhbcOpbGlvcmVyIGxlIGNhY2hlXG4vLyBTZXJ2aWNlIFdvcmtlciBUT1VKT1VSUyBBQ1RJRiBhdmVjIGdlc3Rpb24gYXV0b21hdGlxdWVcbmNvbnN0IENBQ0hFX1ZFUlNJT04gPSAnZW1iLXYxLjIuMCc7XG5jb25zdCBTVEFUSUNfQ0FDSEUgPSBgJHtDQUNIRV9WRVJTSU9OfS1zdGF0aWNgO1xuY29uc3QgRFlOQU1JQ19DQUNIRSA9IGAke0NBQ0hFX1ZFUlNJT059LWR5bmFtaWNgO1xuY29uc3QgQVBJX0NBQ0hFID0gYCR7Q0FDSEVfVkVSU0lPTn0tYXBpYDtcbmNvbnN0IFJVTlRJTUVfQ0FDSEUgPSBgJHtDQUNIRV9WRVJTSU9OfS1ydW50aW1lYDtcblxuLy8gV29ya2JveCBwcmVjYWNoZSBtYW5pZmVzdCAtIHNlcmEgcmVtcGxhY8OpIHBhciBuZXh0LXB3YSBsb3JzIGR1IGJ1aWxkXG5jb25zdCBXQl9NQU5JRkVTVCA9IHNlbGYuX19XQl9NQU5JRkVTVCB8fCBbXTtcblxuLy8gQXNzZXRzIMOgIHByw6ljYWNoZXIgKGVzc2VudGllbHMgcG91ciBsZSBmb25jdGlvbm5lbWVudCBvZmZsaW5lKVxuY29uc3QgUFJFQ0FDSEVfVVJMUyA9IFtcbiAgJy8nLFxuICAnL29mZmxpbmUuaHRtbCcsXG4gICcvbWFuaWZlc3QuanNvbicsXG4gICcvY29uZmlnLmpzb24nLCAvLyBBam91dGVyIGxlIGZpY2hpZXIgZGUgY29uZmlnXG4gICcvbG9nby5wbmcnLFxuICAnL2ljb24tMTkyeDE5Mi5wbmcnLFxuICAnL2ljb24tNTEyeDUxMi5wbmcnLFxuICAvLyBBam91dGVyIGxlcyBhc3NldHMgZ8OpbsOpcsOpcyBwYXIgV29ya2JveFxuICAuLi5XQl9NQU5JRkVTVC5tYXAoZW50cnkgPT4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGVudHJ5IDogZW50cnkudXJsKVxuXTtcblxuLy8gRHVyw6llcyBkZSBjYWNoZSAoZW4gc2Vjb25kZXMpXG5jb25zdCBDQUNIRV9EVVJBVElPTiA9IHtcbiAgc2hvcnQ6IDUgKiA2MCwgICAgICAgLy8gNSBtaW51dGVzIC0gcG91ciBsZXMgZG9ubsOpZXMgZHluYW1pcXVlc1xuICBtZWRpdW06IDMwICogNjAsICAgICAvLyAzMCBtaW51dGVzIC0gcG91ciBsZXMgcGFnZXMgSFRNTFxuICBsb25nOiAyNCAqIDYwICogNjAsICAvLyAyNCBoZXVyZXMgLSBwb3VyIGxlcyBhc3NldHMgc3RhdGlxdWVzXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PSBJTlNUQUxMQVRJT04gPT09PT09PT09PT09PT09PT09PT1cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFsbCcsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnW1NXXSBJbnN0YWxsYXRpb24gdicgKyBDQUNIRV9WRVJTSU9OKTtcblxuICBldmVudC53YWl0VW50aWwoXG4gICAgY2FjaGVzLm9wZW4oU1RBVElDX0NBQ0hFKVxuICAgICAgLnRoZW4oKGNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU1ddIFByw6ljYWNoaW5nIGRlcyBhc3NldHMgZXNzZW50aWVscycpO1xuICAgICAgICByZXR1cm4gY2FjaGUuYWRkQWxsKFBSRUNBQ0hFX1VSTFMpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTV10gRXJyZXVyIHByw6ljYWNoZTonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWVyIG3Dqm1lIGVuIGNhcyBkJ2VycmV1ciBwb3VyIG5lIHBhcyBibG9xdWVyIGwnaW5zdGFsbGF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTV10gSW5zdGFsbGF0aW9uIHRlcm1pbsOpZSAtIEFjdGl2YXRpb24gYXV0b21hdGlxdWUnKTtcbiAgICAgICAgLy8gRm9yY2VyIGwnYWN0aXZhdGlvbiBpbW3DqWRpYXRlIGR1IG5vdXZlYXUgc2VydmljZSB3b3JrZXJcbiAgICAgICAgcmV0dXJuIHNlbGYuc2tpcFdhaXRpbmcoKTtcbiAgICAgIH0pXG4gICk7XG59KTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT0gQUNUSVZBVElPTiA9PT09PT09PT09PT09PT09PT09PVxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdhY3RpdmF0ZScsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnW1NXXSBBY3RpdmF0aW9uIHYnICsgQ0FDSEVfVkVSU0lPTik7XG5cbiAgZXZlbnQud2FpdFVudGlsKFxuICAgIGNhY2hlcy5rZXlzKClcbiAgICAgIC50aGVuKChjYWNoZU5hbWVzKSA9PiB7XG4gICAgICAgIC8vIFN1cHByaW1lciBsZXMgYW5jaWVucyBjYWNoZXNcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgIGNhY2hlTmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKG5hbWUpID0+IG5hbWUuc3RhcnRzV2l0aCgnZW1iLScpICYmIG5hbWUgIT09IFNUQVRJQ19DQUNIRSAmJiBuYW1lICE9PSBEWU5BTUlDX0NBQ0hFICYmIG5hbWUgIT09IEFQSV9DQUNIRSAmJiBuYW1lICE9PSBSVU5USU1FX0NBQ0hFKVxuICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1NXXSBTdXBwcmVzc2lvbiBhbmNpZW4gY2FjaGU6JywgbmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU1ddIFNlcnZpY2UgV29ya2VyIGFjdGl2w6kgZXQgcHJlbmQgbGUgY29udHLDtGxlIGRlIHRvdXRlcyBsZXMgcGFnZXMnKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2xpZW50cy5jbGFpbSgpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gTm90aWZpZXIgdG91cyBsZXMgY2xpZW50cyBxdWUgbGUgU1cgZXN0IGFjdGlmXG4gICAgICAgIHJldHVybiBzZWxmLmNsaWVudHMubWF0Y2hBbGwoKS50aGVuKChjbGllbnRzKSA9PiB7XG4gICAgICAgICAgY2xpZW50cy5mb3JFYWNoKChjbGllbnQpID0+IHtcbiAgICAgICAgICAgIGNsaWVudC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIHR5cGU6ICdTV19BQ1RJVkFURUQnLFxuICAgICAgICAgICAgICB2ZXJzaW9uOiBDQUNIRV9WRVJTSU9OXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICApO1xufSk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09IEZFVENIIChTdHJhdMOpZ2llcyBkZSBjYWNoZSkgPT09PT09PT09PT09PT09PT09PT1cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCAoZXZlbnQpID0+IHtcbiAgY29uc3QgeyByZXF1ZXN0IH0gPSBldmVudDtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG5cbiAgLy8gSWdub3JlciBsZXMgcmVxdcOqdGVzIG5vbi1HRVRcbiAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE5lIHBhcyBjYWNoZXIgY29uZmlnLmpzb24gLSB0b3Vqb3VycyByw6ljdXDDqXJlciBsYSB2ZXJzaW9uIGZyYcOuY2hlXG4gIGlmICh1cmwucGF0aG5hbWUgPT09ICcvY29uZmlnLmpzb24nKSB7XG4gICAgZXZlbnQucmVzcG9uZFdpdGgoXG4gICAgICBmZXRjaChyZXF1ZXN0LCB7IGNhY2hlOiAnbm8tc3RvcmUnIH0pLmNhdGNoKCgpID0+IGNhY2hlcy5tYXRjaChyZXF1ZXN0KSlcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFN0cmF0w6lnaWUgcG91ciBsZXMgcmVxdcOqdGVzIEFQSSAtIE5ldHdvcmsgRmlyc3QgYXZlYyB0aW1lb3V0IGNvdXJ0XG4gIGlmICh1cmwucGF0aG5hbWUuc3RhcnRzV2l0aCgnL2FwaS8nKSkge1xuICAgIGV2ZW50LnJlc3BvbmRXaXRoKG5ldHdvcmtGaXJzdFdpdGhUaW1lb3V0U3RyYXRlZ3kocmVxdWVzdCwgQVBJX0NBQ0hFLCAzMDAwKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU3RyYXTDqWdpZSBwb3VyIGxlcyBpbWFnZXMgLSBDYWNoZSBGaXJzdFxuICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiA9PT0gJ2ltYWdlJykge1xuICAgIGV2ZW50LnJlc3BvbmRXaXRoKGNhY2hlRmlyc3RTdHJhdGVneShyZXF1ZXN0LCBEWU5BTUlDX0NBQ0hFKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gU3RyYXTDqWdpZSBwb3VyIGxlcyBhc3NldHMgc3RhdGlxdWVzIChKUywgQ1NTLCBmb250cykgLSBDYWNoZSBGaXJzdFxuICBpZiAoXG4gICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9PT0gJ3NjcmlwdCcgfHxcbiAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID09PSAnc3R5bGUnIHx8XG4gICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9PT0gJ2ZvbnQnXG4gICkge1xuICAgIGV2ZW50LnJlc3BvbmRXaXRoKGNhY2hlRmlyc3RTdHJhdGVneShyZXF1ZXN0LCBTVEFUSUNfQ0FDSEUpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTdHJhdMOpZ2llIE9QVElNQUxFIHBvdXIgbGVzIHBhZ2VzIEhUTUwgLSBTdGFsZS1XaGlsZS1SZXZhbGlkYXRlXG4gIC8vIFNlcnQgaW1tw6lkaWF0ZW1lbnQgZHUgY2FjaGUgdG91dCBlbiBtZXR0YW50IMOgIGpvdXIgZW4gYXJyacOocmUtcGxhblxuICAvLyDDiVZJVEUgTEVTIFJBRlJBw45DSElTU0VNRU5UUyAhXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uID09PSAnZG9jdW1lbnQnIHx8IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2FjY2VwdCcpPy5pbmNsdWRlcygndGV4dC9odG1sJykpIHtcbiAgICBldmVudC5yZXNwb25kV2l0aChzdGFsZVdoaWxlUmV2YWxpZGF0ZVN0cmF0ZWd5KHJlcXVlc3QsIFJVTlRJTUVfQ0FDSEUpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQYXIgZMOpZmF1dCAtIFN0YWxlLVdoaWxlLVJldmFsaWRhdGVcbiAgZXZlbnQucmVzcG9uZFdpdGgoc3RhbGVXaGlsZVJldmFsaWRhdGVTdHJhdGVneShyZXF1ZXN0LCBSVU5USU1FX0NBQ0hFKSk7XG59KTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT0gU1RSQVTDiUdJRVMgREUgQ0FDSEUgPT09PT09PT09PT09PT09PT09PT1cblxuLy8gTmV0d29yayBGaXJzdDogRXNzYWllIGxlIHLDqXNlYXUgZCdhYm9yZCwgcHVpcyBsZSBjYWNoZVxuYXN5bmMgZnVuY3Rpb24gbmV0d29ya0ZpcnN0U3RyYXRlZ3kocmVxdWVzdCwgY2FjaGVOYW1lKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcblxuICAgIC8vIE1ldHRyZSBlbiBjYWNoZSBzZXVsZW1lbnQgbGVzIHLDqXBvbnNlcyB2YWxpZGVzXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKGNhY2hlTmFtZSk7XG4gICAgICBjYWNoZS5wdXQocmVxdWVzdCwgcmVzcG9uc2UuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFNpIGxlIHLDqXNlYXUgw6ljaG91ZSwgY2hlcmNoZXIgZGFucyBsZSBjYWNoZVxuICAgIGNvbnN0IGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgY2FjaGVzLm1hdGNoKHJlcXVlc3QpO1xuXG4gICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdmVycyBsYSBwYWdlIG9mZmxpbmUgcG91ciBsZXMgcGFnZXMgSFRNTFxuICAgIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICByZXR1cm4gY2FjaGVzLm1hdGNoKCcvb2ZmbGluZS5odG1sJyk7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gQ2FjaGUgRmlyc3Q6IENoZXJjaGUgZGFucyBsZSBjYWNoZSBkJ2Fib3JkLCBwdWlzIGxlIHLDqXNlYXVcbmFzeW5jIGZ1bmN0aW9uIGNhY2hlRmlyc3RTdHJhdGVneShyZXF1ZXN0LCBjYWNoZU5hbWUpIHtcbiAgY29uc3QgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZXMubWF0Y2gocmVxdWVzdCk7XG5cbiAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKGNhY2hlTmFtZSk7XG4gICAgICBjYWNoZS5wdXQocmVxdWVzdCwgcmVzcG9uc2UuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTV10gRXJyZXVyIGZldGNoOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBTdGFsZS1XaGlsZS1SZXZhbGlkYXRlOiBSZXRvdXJuZSBsZSBjYWNoZSBpbW3DqWRpYXRlbWVudCBldCBtZXQgw6Agam91ciBlbiBhcnJpw6hyZS1wbGFuXG4vLyBNRUlMTEVVUkUgU1RSQVTDiUdJRSBQT1VSIMOJVklURVIgTEVTIFJBRlJBw45DSElTU0VNRU5UU1xuYXN5bmMgZnVuY3Rpb24gc3RhbGVXaGlsZVJldmFsaWRhdGVTdHJhdGVneShyZXF1ZXN0LCBjYWNoZU5hbWUpIHtcbiAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihjYWNoZU5hbWUpO1xuICBjb25zdCBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlcy5tYXRjaChyZXF1ZXN0KTtcblxuICAvLyBQcm9tZXNzZSBkZSBtaXNlIMOgIGpvdXIgZW4gYXJyacOocmUtcGxhblxuICBjb25zdCBmZXRjaFByb21pc2UgPSBmZXRjaChyZXF1ZXN0KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIC8vIE1ldHRyZSDDoCBqb3VyIGxlIGNhY2hlIGVuIGFycmnDqHJlLXBsYW4gdW5pcXVlbWVudCBzaSBzdWNjw6hzXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBjYWNoZS5wdXQocmVxdWVzdCwgcmVzcG9uc2UuY2xvbmUoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignW1NXXSBFcnJldXIgZmV0Y2ggYmFja2dyb3VuZDonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuXG4gIC8vIFJldG91cm5lciBpbW3DqWRpYXRlbWVudCBsZSBjYWNoZSBzJ2lsIGV4aXN0ZSwgc2lub24gYXR0ZW5kcmUgbGUgcsOpc2VhdVxuICByZXR1cm4gY2FjaGVkUmVzcG9uc2UgfHwgZmV0Y2hQcm9taXNlIHx8IGNhY2hlcy5tYXRjaCgnL29mZmxpbmUuaHRtbCcpO1xufVxuXG4vLyBOZXR3b3JrIEZpcnN0IGF2ZWMgdGltZW91dDogRXNzYWllIGxlIHLDqXNlYXUgYXZlYyB1biB0aW1lb3V0LCBwdWlzIGxlIGNhY2hlXG5hc3luYyBmdW5jdGlvbiBuZXR3b3JrRmlyc3RXaXRoVGltZW91dFN0cmF0ZWd5KHJlcXVlc3QsIGNhY2hlTmFtZSwgdGltZW91dCA9IDMwMDApIHtcbiAgdHJ5IHtcbiAgICAvLyBDcsOpZXIgdW5lIHByb21lc3NlIGF2ZWMgdGltZW91dFxuICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCcpKSwgdGltZW91dClcbiAgICApO1xuXG4gICAgY29uc3QgZmV0Y2hQcm9taXNlID0gZmV0Y2gocmVxdWVzdCk7XG5cbiAgICAvLyBDb3Vyc2UgZW50cmUgZmV0Y2ggZXQgdGltZW91dFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtmZXRjaFByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG5cbiAgICAvLyBNZXR0cmUgZW4gY2FjaGUgc2V1bGVtZW50IGxlcyByw6lwb25zZXMgdmFsaWRlc1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihjYWNoZU5hbWUpO1xuICAgICAgY2FjaGUucHV0KHJlcXVlc3QsIHJlc3BvbnNlLmNsb25lKCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBTaSB0aW1lb3V0IG91IGVycmV1ciByw6lzZWF1LCBjaGVyY2hlciBkYW5zIGxlIGNhY2hlXG4gICAgY29uc3QgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZXMubWF0Y2gocmVxdWVzdCk7XG5cbiAgICBpZiAoY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU1ddIFV0aWxpc2F0aW9uIGR1IGNhY2hlIHN1aXRlIMOgIHRpbWVvdXQvZXJyZXVyJyk7XG4gICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdmVycyBsYSBwYWdlIG9mZmxpbmUgcG91ciBsZXMgZG9jdW1lbnRzXG4gICAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gPT09ICdkb2N1bWVudCcpIHtcbiAgICAgIHJldHVybiBjYWNoZXMubWF0Y2goJy9vZmZsaW5lLmh0bWwnKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PSBOT1RJRklDQVRJT05TIFBVU0ggPT09PT09PT09PT09PT09PT09PT1cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcigncHVzaCcsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnW1NXXSBQdXNoIHJlw6d1OicsIGV2ZW50KTtcblxuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpY29uOiAnL2xvZ28ucG5nJyxcbiAgICBiYWRnZTogJy9sb2dvLnBuZycsXG4gICAgdmlicmF0ZTogWzIwMCwgMTAwLCAyMDBdLFxuICAgIHJlcXVpcmVJbnRlcmFjdGlvbjogdHJ1ZSxcbiAgICBhY3Rpb25zOiBbXG4gICAgICB7IGFjdGlvbjogJ29wZW4nLCB0aXRsZTogJ091dnJpcicgfSxcbiAgICAgIHsgYWN0aW9uOiAnY2xvc2UnLCB0aXRsZTogJ0Zlcm1lcicgfVxuICAgIF1cbiAgfTtcblxuICBsZXQgbm90aWZpY2F0aW9uRGF0YSA9IHtcbiAgICB0aXRsZTogJ0VNQiBUcmFuc2ZlcicsXG4gICAgYm9keTogJ05vdXZlbGxlIG5vdGlmaWNhdGlvbicsXG4gICAgLi4uZGVmYXVsdE9wdGlvbnNcbiAgfTtcblxuICBpZiAoZXZlbnQuZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YS5qc29uKCk7XG4gICAgICBub3RpZmljYXRpb25EYXRhID0ge1xuICAgICAgICB0aXRsZTogZGF0YS50aXRsZSB8fCAnRU1CIFRyYW5zZmVyJyxcbiAgICAgICAgYm9keTogZGF0YS5tZXNzYWdlIHx8IGRhdGEuYm9keSB8fCAnTm91dmVsbGUgbm90aWZpY2F0aW9uJyxcbiAgICAgICAgaWNvbjogZGF0YS5pY29uIHx8IGRlZmF1bHRPcHRpb25zLmljb24sXG4gICAgICAgIGJhZGdlOiBkYXRhLmJhZGdlIHx8IGRlZmF1bHRPcHRpb25zLmJhZGdlLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB2aWJyYXRlOiBkZWZhdWx0T3B0aW9ucy52aWJyYXRlLFxuICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb246IGRlZmF1bHRPcHRpb25zLnJlcXVpcmVJbnRlcmFjdGlvbixcbiAgICAgICAgYWN0aW9uczogZGVmYXVsdE9wdGlvbnMuYWN0aW9ucyxcbiAgICAgICAgdGFnOiBkYXRhLnRhZyB8fCAnZW1iLW5vdGlmaWNhdGlvbicsXG4gICAgICAgIHJlbm90aWZ5OiB0cnVlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTV10gRXJyZXVyIHBhcnNpbmcgbm90aWZpY2F0aW9uOicsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGV2ZW50LndhaXRVbnRpbChcbiAgICBzZWxmLnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbkRhdGEudGl0bGUsIG5vdGlmaWNhdGlvbkRhdGEpXG4gICk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdub3RpZmljYXRpb25jbGljaycsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnW1NXXSBOb3RpZmljYXRpb24gY2xpcXXDqWU6JywgZXZlbnQpO1xuXG4gIGV2ZW50Lm5vdGlmaWNhdGlvbi5jbG9zZSgpO1xuXG4gIGlmIChldmVudC5hY3Rpb24gPT09ICdjbG9zZScpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBldmVudC53YWl0VW50aWwoXG4gICAgY2xpZW50cy5tYXRjaEFsbCh7IHR5cGU6ICd3aW5kb3cnLCBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlIH0pXG4gICAgICAudGhlbigoY2xpZW50TGlzdCkgPT4ge1xuICAgICAgICAvLyBDaGVyY2hlciB1bmUgZmVuw6p0cmUgb3V2ZXJ0ZSBldCBsYSBmb2N1c1xuICAgICAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiBjbGllbnRMaXN0KSB7XG4gICAgICAgICAgaWYgKGNsaWVudC51cmwuaW5kZXhPZihzZWxmLmxvY2F0aW9uLm9yaWdpbikgPj0gMCAmJiAnZm9jdXMnIGluIGNsaWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdXZyaXIgdW5lIG5vdXZlbGxlIGZlbsOqdHJlIHNpIGF1Y3VuZSBuJ2VzdCBvdXZlcnRlXG4gICAgICAgIGlmIChjbGllbnRzLm9wZW5XaW5kb3cpIHtcbiAgICAgICAgICByZXR1cm4gY2xpZW50cy5vcGVuV2luZG93KCcvZGFzaGJvYXJkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICk7XG59KTtcblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdub3RpZmljYXRpb25jbG9zZScsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnW1NXXSBOb3RpZmljYXRpb24gZmVybcOpZTonLCBldmVudCk7XG59KTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT0gQkFDS0dST1VORCBTWU5DID09PT09PT09PT09PT09PT09PT09XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ3N5bmMnLCAoZXZlbnQpID0+IHtcbiAgY29uc29sZS5sb2coJ1tTV10gQmFja2dyb3VuZCBzeW5jOicsIGV2ZW50LnRhZyk7XG5cbiAgaWYgKGV2ZW50LnRhZyA9PT0gJ3N5bmMtdHJhbnNhY3Rpb25zJykge1xuICAgIGV2ZW50LndhaXRVbnRpbChzeW5jVHJhbnNhY3Rpb25zKCkpO1xuICB9XG59KTtcblxuYXN5bmMgZnVuY3Rpb24gc3luY1RyYW5zYWN0aW9ucygpIHtcbiAgdHJ5IHtcbiAgICAvLyBTeW5jaHJvbmlzZXIgbGVzIGRvbm7DqWVzIGVuIGF0dGVudGVcbiAgICBjb25zb2xlLmxvZygnW1NXXSBTeW5jaHJvbmlzYXRpb24gZGVzIHRyYW5zYWN0aW9ucy4uLicpO1xuICAgIC8vIEltcGzDqW1lbnRlciBsYSBsb2dpcXVlIGRlIHN5bmNocm9uaXNhdGlvbiBpY2lcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU1ddIEVycmV1ciBzeW5jOicsIGVycm9yKTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PSBQRVJJT0RJQyBCQUNLR1JPVU5EIFNZTkMgPT09PT09PT09PT09PT09PT09PT1cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcigncGVyaW9kaWNzeW5jJywgKGV2ZW50KSA9PiB7XG4gIGNvbnNvbGUubG9nKCdbU1ddIFBlcmlvZGljIHN5bmM6JywgZXZlbnQudGFnKTtcblxuICBpZiAoZXZlbnQudGFnID09PSAnY29udGVudC1zeW5jJykge1xuICAgIGV2ZW50LndhaXRVbnRpbChwZXJpb2RpY0NvbnRlbnRTeW5jKCkpO1xuICB9XG59KTtcblxuYXN5bmMgZnVuY3Rpb24gcGVyaW9kaWNDb250ZW50U3luYygpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnW1NXXSBTeW5jaHJvbmlzYXRpb24gcMOpcmlvZGlxdWUgZHUgY29udGVudS4uLicpO1xuICAgIC8vIENldHRlIGZvbmN0aW9uIHMnZXjDqWN1dGUgcMOpcmlvZGlxdWVtZW50IHBvdXIgbWFpbnRlbmlyIGxlIFNXIGFjdGlmXG4gICAgLy8gZXQgc3luY2hyb25pc2VyIGxlcyBkb25uw6llcyBlbiBhcnJpw6hyZS1wbGFuXG5cbiAgICAvLyBWw6lyaWZpZXIgZXQgbWV0dHJlIMOgIGpvdXIgbGVzIGNhY2hlcyBjcml0aXF1ZXNcbiAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKFNUQVRJQ19DQUNIRSk7XG4gICAgY29uc3QgY2FjaGVkVXJscyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcblxuICAgIGNvbnNvbGUubG9nKCdbU1ddIENvbnRlbnUgZW4gY2FjaGU6JywgY2FjaGVkVXJscy5sZW5ndGgsICfDqWzDqW1lbnRzJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1NXXSBFcnJldXIgc3luYyBww6lyaW9kaXF1ZTonLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT0gTUVTU0FHRSA9PT09PT09PT09PT09PT09PT09PVxuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gIGNvbnNvbGUubG9nKCdbU1ddIE1lc3NhZ2UgcmXDp3U6JywgZXZlbnQuZGF0YSk7XG5cbiAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS50eXBlID09PSAnU0tJUF9XQUlUSU5HJykge1xuICAgIHNlbGYuc2tpcFdhaXRpbmcoKTtcbiAgfVxuXG4gIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSA9PT0gJ0NMRUFSX0NBQ0hFJykge1xuICAgIGV2ZW50LndhaXRVbnRpbChcbiAgICAgIGNhY2hlcy5rZXlzKCkudGhlbigoY2FjaGVOYW1lcykgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgY2FjaGVOYW1lcy5tYXAoKG5hbWUpID0+IGNhY2hlcy5kZWxldGUobmFtZSkpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUgPT09ICdDSEVDS19VUERBVEUnKSB7XG4gICAgLy8gRm9yY2VyIGxhIHbDqXJpZmljYXRpb24gZGUgbWlzZSDDoCBqb3VyXG4gICAgZXZlbnQud2FpdFVudGlsKFxuICAgICAgc2VsZi5yZWdpc3RyYXRpb24udXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU1ddIFbDqXJpZmljYXRpb24gZGUgbWlzZSDDoCBqb3VyIGVmZmVjdHXDqWUnKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOlsiQ0FDSEVfVkVSU0lPTiIsIlNUQVRJQ19DQUNIRSIsIkRZTkFNSUNfQ0FDSEUiLCJBUElfQ0FDSEUiLCJSVU5USU1FX0NBQ0hFIiwiV0JfTUFOSUZFU1QiLCJzZWxmIiwiX19XQl9NQU5JRkVTVCIsIlBSRUNBQ0hFX1VSTFMiLCJtYXAiLCJlbnRyeSIsInVybCIsIkNBQ0hFX0RVUkFUSU9OIiwic2hvcnQiLCJtZWRpdW0iLCJsb25nIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiY29uc29sZSIsImxvZyIsIndhaXRVbnRpbCIsImNhY2hlcyIsIm9wZW4iLCJ0aGVuIiwiY2FjaGUiLCJhZGRBbGwiLCJjYXRjaCIsImVycm9yIiwic2tpcFdhaXRpbmciLCJrZXlzIiwiY2FjaGVOYW1lcyIsIlByb21pc2UiLCJhbGwiLCJmaWx0ZXIiLCJuYW1lIiwic3RhcnRzV2l0aCIsImRlbGV0ZSIsImNsaWVudHMiLCJjbGFpbSIsIm1hdGNoQWxsIiwiZm9yRWFjaCIsImNsaWVudCIsInBvc3RNZXNzYWdlIiwidHlwZSIsInZlcnNpb24iLCJyZXF1ZXN0IiwiVVJMIiwibWV0aG9kIiwicGF0aG5hbWUiLCJyZXNwb25kV2l0aCIsImZldGNoIiwibWF0Y2giLCJuZXR3b3JrRmlyc3RXaXRoVGltZW91dFN0cmF0ZWd5IiwiZGVzdGluYXRpb24iLCJjYWNoZUZpcnN0U3RyYXRlZ3kiLCJoZWFkZXJzIiwiZ2V0IiwiaW5jbHVkZXMiLCJzdGFsZVdoaWxlUmV2YWxpZGF0ZVN0cmF0ZWd5IiwibmV0d29ya0ZpcnN0U3RyYXRlZ3kiLCJjYWNoZU5hbWUiLCJyZXNwb25zZSIsInN0YXR1cyIsInB1dCIsImNsb25lIiwiY2FjaGVkUmVzcG9uc2UiLCJmZXRjaFByb21pc2UiLCJ0aW1lb3V0IiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsIkVycm9yIiwicmFjZSIsImRlZmF1bHRPcHRpb25zIiwiaWNvbiIsImJhZGdlIiwidmlicmF0ZSIsInJlcXVpcmVJbnRlcmFjdGlvbiIsImFjdGlvbnMiLCJhY3Rpb24iLCJ0aXRsZSIsIm5vdGlmaWNhdGlvbkRhdGEiLCJib2R5IiwiZGF0YSIsImpzb24iLCJtZXNzYWdlIiwidGFnIiwicmVub3RpZnkiLCJlIiwicmVnaXN0cmF0aW9uIiwic2hvd05vdGlmaWNhdGlvbiIsIm5vdGlmaWNhdGlvbiIsImNsb3NlIiwiaW5jbHVkZVVuY29udHJvbGxlZCIsImNsaWVudExpc3QiLCJpbmRleE9mIiwibG9jYXRpb24iLCJvcmlnaW4iLCJmb2N1cyIsIm9wZW5XaW5kb3ciLCJzeW5jVHJhbnNhY3Rpb25zIiwicGVyaW9kaWNDb250ZW50U3luYyIsImNhY2hlZFVybHMiLCJsZW5ndGgiLCJ1cGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/sw.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./public/sw.js");
/******/ 	
/******/ })()
;